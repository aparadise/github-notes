Commands for unix

1) ls -l (this will list all the directorys by a FULL detal view with date, size and name. however 'ls -al' will do the same but show hidden files )

2) ls -al (will show all file details including hidden files. however 'ls -l' WILL not show hidden files)

3) ls (this will give full file list of the names in directory only)

4) To change a file name type: $ mv fileName (space) newFileName

5) $ git log (this will show you the  history of the files)  (note depending your unix editor you can just type "q" to escape out of the log view)

6) $ git log --oneline (this is a much simple cleaner look at the FULL log history of ALL COMMITED FILES.)

7) $ git init (this is how you create a NEW git repository.) 

8) use the vi editor to edit in the terminal type: vi FileName

9) $ git commit -a -m "message name" or $ git commit -am "message" (fast way to commit a file is called "express commit")

10) type: $ cat FileName (this will show you the file contents without having to use the VI editor)

11) $ git checkout -b new-Branch-Name (to add a new branch AFTER you detach a file from head to make changes)

12) $ git add . (return/enter)(note--- if you use git '$ git add .' you are adding ALL the files that are in the staging area) $ git commit -m "some message"

13) how to "revert" a commited file. type: $ git revert HEAD (this will auto open VI editor to make changes)

14) REMOVE A FILE in unix type (you DO NOT need to type 'git'): rm file-name

15) $ git reset --hard file-ID (this will reset the head at the the file-ID that you choose from the reset --hard) 

16) $ git init (this is how you make github working directory after you have made a new folder)

17) $ touch new-File-Name (type the 'touch' command to quickly add a new file instead of the VI editor)


18) note: you TAG a file by adding it to your staging area type: $ git add file-Name

19)  $ git clean -n ("-n" is only warning to let you know that it will show you what files will be removed before acutally removing the untracked files)

20)  $ git clean -f (this actually will remove the untracked file. "-f" means force flag.)

21) $ git clean -f <path-name> (this will clean all untracked files located in that FILES FOLDER ONLY)

22) $ git clean -df (the will removes all tracked and untracked files in the current directory)

23)  $ git clean -xf (this is for deleting files that are set to "ignore" in git.)


24) ls -al (will show all file details including hidden files. however 'ls -l' WILL not show hidden files)

25) git clone url (this is the url from github repo)

26) git pull origin master

27) git push origin master

note 26 & 27 "git pull origin master" means... "origin" is the remote repository and "master" points to the master branch of the remote repository.
and...  "git push origin master" means ... "origin" refers to the remote repository and "master" refers to the master branch of your local repository

note: $ git remote -v  (this will show you if your folder/files are linked to your remote git repo)  https://www.youtube.com/watch?v=O72FWNeO-xY

note: $ git remote origin folderName (this you will force a new repo if you do not do it from inside of git)



28) $ git diff

29) $ git difftool  (on mac to get the merge tool to open you must type: $ git mergetool )

******>>>> note: working with difftool on the LEFT side is the staging area RIGHT side is local area (refere here: https://gist.github.com/tony4d/3454372)

note: working with difftool on the LEFT side is the staging area RIGHT side is local area

30) $ git diff HEAD (this will hightlight the different line changes)

31) $ git difftool HEAD (this will hightlight the different line changes)

32) $ git diff --staged HEAD (this is the same as: $ git diff --cached HEAD)

33) $ git diff --cached HEAD (this is the same as: $ git diff --staged HEAD)

34) $ git diff ID HEAD

35) $ git difftool ID HEAD

36) $ git difftool HEAD^ HEAD (yes that is HEAD^ HEAD. i need to remember this line. this will compare the ID you want to the HEAD)

37) $ git difftool HEAD~1 HEAD (yes that is HEAD~1 HEAD. i need to remember this line. this will compare the ID in reverse count from the HEAD. The tilda '~' is like minus sign it subtracts the count from the head, so i can go HEAD~2 from the HEAD)

38) $ git diff ID HEAD (i need to remember this line)

39) $ git difftool ID HEAD (i need to remember this line. this will compare the ID you want to the HEAD^)

40) $ git difftool ID ID (this will compare two ID's instead of comparing against the HEAD)


note: if git stuck in the terminal and i see ":" in the bottom left corner type hit the "space bar" then type the letter "q"

41) $ git diff master origin/master (this will compare your local master to the origin master on github)


42) 41) $ git difftool master origin/master (this will compare your local master to the origin master on github)

43) $ git checkout -b newBranchName (how you create a NEW branch. once you do this it will auto kick you out of the current branch into the create branch. the it will inherit all of the commits from its parent branch)

44) $ git diff  master localBranchName (this will run diff between the two branches)

45) $ git difftool master localBranchName (this will run diff between the two branches)

47) $ git mergetool (this gives a 3 way merge look at the conflicts)

  Note: the merge conficted files will show where the conflict starts and stops. When it stops it will show what branch the file is in..

48) you can make your own ' .ignore" file to stop git from tracking any files you do not want to be kept tracked of.


* 49) $ git remote -v (must know this. this is how you can see the push/pull from orgin url)

* 50) $ git log --oneline origin/master (this will show me ONLY the local working copies history)

 51) $ git log --oneline origin/master

 52) $ git fetch origin master

 53) $ git branch -r (shows the invisibale origin/master branches)

 54) $ git branch -a ( you can see both local and remote branches)




****Branching notes***

  46.  $ git log -oneline —decorate —graph —all  (this will show information in great details)
  47.  $git log —stat (this will show you files altered and lined deleted. and when you hit space bar you can see files)
  48.  $ git log —stat —oneline -n  2 (limit it two commits)
  49.  $ git log -p (this  is to see patches. this is GREAT to see full edit of code for diff )
  50.  $ git log -p —oneline -n 1 (you can limit to just one line of commits or -1)
  51.  $ git log  directoryName (this let is GREAT for just looking commit history JUST in a specific directory)
  52.  $ git log —oneline —grep=“football” (how to search for a string in a branch. ‘—grep’ is the key to search lines matching a regular expression) 



note: A git “branch” represents and independent line of development.


We create a NEW BRANCH when we want to develop a new feature or a bug fix no matter if its big or small. Because new code is NEVER committed to the main master branch until its passed in the release QA branch, QA approves its and releases a push to the master branch. A new branch ALWAYS gets town working directory, index or staging area and commit history automatically once you create it.


 53.   $ git branch -a (this means to see ALL the branches you have. it will show all)
 54.   $ git branch a (this will JUST return your local branches)
 55.   $ git branch newBranch name (this is how you make a new branch)
       $ git checkout -b newBranchName (how you create a NEW branch. once you do this it will auto kick you out of the current branch into     the create branch. the it will inherit all of the commits from its parent branch)
 
 56.   $ git branch -m currentBranchName NewBranchName (this will change the name of the old current branch to rename it)
 57.   $ git branch -d branchName (this is how you delete a branch)
 58.   $ git branch -D branchName  (this is warning from git that you must type a capital “-D” if you want to delete a sub branch that has NOT been merged. This way git will not allow you to accidentally delete a branch that has changes that you have not merged to the master branch yet just to make sure. So -D will allow you to delete a branch that does not have merged files.) 


note:  you will see all of your branches you will notice that your sub branches are under the master branch. Then you will need to checkout the subbranch you want to work into that branch to create directories and files..
 

**** RULES for deleting files ****

59) a) DELETE FILES: $ git rm yourFileName (if does not work try and add the file first: $ git add . fileName)

    b) after you delete a file do get status to see the removed file: $ git status

    c) next type: $ git commit -m "last status before i deleted file from local"

    note: remember  you are only deleting the file from local NOT the git repo this way. To actually delete the file from the git repo you must do another step

    d) delete a entire branch type: $ git branch -d yourBranchName ( you want be able to delete the branch if the files inside HAS NOT been commited. so if you are sure that you dont want to commit      anything  in the branch then you can for the branch to delete by typing: $ git branch -D branchName (notice its a capital "D")

note: to list your branches type: $ git branch -a
note: always check your branches:  $ git log --oneline —-decorate -—graph -—all

**** --amend --no-edit

60) $ git --amend --no-edit (this will allow you commit a file without giving a new message and just keep the message from before)






********************Unzip a file **********

$ unzip yourFile.zip

*********remove a file *************

$ rm Filename

**********to make a NEW directory folder ***********

$ mkdir newDirectoryName

****Copy Files to another locaction *********

$ cp -rf theFilesYouWant2CopyName/* NewDirectoryToPasteLocation/

********create NEW git repository ********

$ git init

********** to check the status before adding files *********

$ git status
(if its red color then you need to make a decision if you want to add the red uncommited file)

******add the files to the directory *******

$ git add .

(this add ALL of your files. once you see your files are now green by checking the '$ git status' after you have added the files you now need to leave a committed message.

type: $ git commit -m "your messages"

*********faster way to add files and leave a message at one time instead of two steps use the "EXPRESS COMMIt" ****

 type: $ git commit -am "message name"


**********SPECIAL NOTE****
If you '$ git status' and you get "CLEAN" message that a good sign meaning there is nothing has been touched and everthing
has been commited.

***********VI Editor ************
1) in unix type 'vi' then a makeup a "file name"
2) once inside of vi type "i" for this will all allow you insert text into the vi.
3) once done hit the "esc' key twice and type ":wq" this will allow you to save the file.

4) then to check the file to see if its added type '$ cat filleName' (hit enter/return) and '$ git log --oneline' or '$ git status'


*************************

******add files to github ***********

1) $ git status (this will show all files that has not been commited (this show you the branch our one and the status of files)
(the file status will always be in RED)

2) $ git add fileName (enter/return) (this how you add file)

3) type: '$ git status'  or '$ git status -s' (enter/return) (now you will see the GREEN fileName that was added and RED files that has not been added)

4) To remove the file that you added type: $ git rm --cached fileName (enter/return) then type: $ git status (you should now see  your file in RED)

5) to finalize a commited file (after step 3). type: $ git commit -m "message" (yes you must type "some message" after -m. this for comments for a commit)

--> note: you can also type: $ git status -s (this will give a better look of files that has not been commited. 
It will show you a RED "?" or GREEN "A" or RED "M" If its GREEN "M" that mean is was modified and added. A RED "D" means deleted.
 
****************



*****Copying a GitHub Respoitory******

when you "Fork" someones project you clone it to YOUR github accout.
once you copy the forked url from your github account do the following steps to in the unix terminal to copy it down to your local.


1) $ cd <project_directory>
2) $ git clone (or just copy/paste the url) https://github.com/<user>/<project_name>
3) $ cd <project name>
4) ls -al

note: if you do 'ls -al' in the directory and you see '.git' that means it has been successfully cloned into your repository.
*******************************

****moving files into a github***

1) Modified
2) Staged
3) Commited

****************

**** how to check the status of the repository by using $ git status -s ***

you can also type: $ git status -s (this will give a better look of files that has not been commited. 
It will show you a RED "?" or GREEN "A" or RED "M" If its GREEN "M" that mean is was modified and added. A RED "D" means deleted.

also if you need to change a file name type: $ mv fileName (space) newFileName.

*************************************************

********* git log commands *****

there are 5 ways to git log views

1) $ git log (this will show you the  history of the files)  (note depending your unix editor you can just type "q" to escape out of the log view)

2) a much simple cleaner look is type: $ git log --oneline

3) see only the log history of one file type: $ git log fileName

4) to view all logs for one files history by date by grabbing typing the commited ID number type: $ git log 88888..99999 --oneline

5) to view only the last 3 commits for example type: $ git log -n 3 --oneline


***** Branching ***

1) to see the branches type: $ git branch

2) to make a branch type: $ git branch nameOfNewBranch

3) to check out a branch or switch to a different branch type: $ git checkout nameOftheBranch

branches will inhirit ALL files from the MASTER branch but new files created in the checkedout branch will on go into that current branch until its pushed to the master branch.

note: a cyle for a branch looks like this:

Master (final bug free files)
Release (testing before pushed to master)
Development (is where developers can work together and the Release branch can be created from the development branch)
Feature (this branch is only for new features)
Feature (this branch is only for new features)

*****************************

*****github CHECKOUT commands ***

You can use a checkout to: checkout files, branches and commits.
 
A) How to checkout a COMMIT

  1) type: $ git checkout YourCommited-ID

  2) to see the history of the commited files type: "git log --oneline"

  (note: when all of the commited files are shown the top most current commited file is called "THE HEAD"

  3) $ git checkout IDnameOfcommitedFile  (once you do this the files is now called the "detached head". 

  Once you do a desatched head. then thee working file come your. YOu can make exprential changes to them, and you can discard any   commits without impacting any changes)

  4) now if you want to checkout a file and place it in a NEW BRANCH! type: $ git checkout -b newBranchName

  5) If you want to create a new branch to retain the new commits type: $ git checkout -b NewBranchName


B) How to CHECKOUT a branch

   1) type: $ git checkout master (this will tell what the head posisiton file is in your branch. to see the commited order type:       $ git log --oneline )
  
   2) If i want checkout any file from current branch that I am in type: $ git checkout ID-name (note: when you do this you will 
     see a message that say... you are in "detached HEAD" state. this means you can look around in the file and make experimental      changes and commit them, and you can discard any commits you make in this state without impacting any other branches by          perfroming another checkout.  Now from here you can also create a new branch to retain commits you create, you may do so (now     or later) by     typing: $ git checkout -b new-Branch-Name)

    note: once detach file from the head and then type '$ git log --oneline' you notice that you are NOW only able to see files
   up to the detached file in the head. So you should see less amount of files in the log view.

3) after you make changes to a file that is checked out commit the file type: $ git -am "message information" 
   you will now see message telling you how many files have chagned and how many lined where (+) added or (-) subtracted.

  note: once you add the new changes from the checked out detached file try and run checkout the branch again type: $ git checkout  master you will get a WARNING MESSAGE saying your are about to leave 1 commit behind. If you to keep the changes you must make new branch so you would have to type: $ git checkout -b new-Branch-Name.

4) VERY IMPORTANT... now if you want to actual do a '$ git checkout ID file-name' and now you want to update the current branch to save those changes YOU MUST combine file-ID and the Name of the file. type: $ git checkout ID fileName (once you have done do a '$ git status' to see what the file done.

5) VERY IMPORTANT... now if i dont want to commit the file after i its done "$ git checkout ID file-name" i can type: $ git checkout HEAD file-name (then type: '$ git status' i should get a message that says 'nothing to commit, working diretory clean')

6) when you run a 'checkout'command it automatically addes the file to the staging area so you just have to run '-m' command to leave a mesage. $ git commit -m "some message"

7) how to "revert" a commited file. type: $ git revert HEAD (this will auto open VI editor to make changes)
note: what the commit "revert" does is removes the commited snapshot.

8) "git revert HEAD" command does the following.. reverts current commit but introduces a new commit for the reversal.

Note: get revert IS A SAFE WAY to undo changes.

************git RESET command *********

Note: get reset is a VERY DANGEROUS way to do changes. When you use "$ git reset" its permanent change YOU CAN NOT go back change it again.

NOte: The Rule ONLY use '$ git reset' on your local files NEVER where other developers are sharing on stage/master 

1) $ git reset

(you will use reset when you make change on a file and you add it before leaving a message)

2) $ git reset --hard (this will remove the modified file from the HEAD of the stage. do 'git status' to see a clean dirctory)
(not only did it remove the changes in STAGING area but ALSO modified the work in WORKING directory to match the most recent changes)

3) $ git reset --hard file-ID (this will reset the head at the the file-ID that you choose from the reset --hard) 

**********git clean ************
 git clean removes UNSTRACKED FILES from your working directory.

 git clean commans is NOT UNCHANGLALBE so make sure your 100% sure you want to do this.

note: git "reset" ONLY works on "TRACKED" files but git "clean" ONLY work on "UNTRACKED" files.

note: git 'clean' and git '--hard' allows you to reset the working directory back to its orginal state.

1)  $ git clean -n ("-n" is only warning to let you know that it will show you what files will be removed before acutally removing the untracked files)

2)  $ git clean -f (this actually will remove the untracked file. "-f" means force flag.)


3) $ git clean -f <path-name> (this will clean all files located in that FILES FOLDER ONLY)

4) $ git clean -df (the will removes all tracked and untracked files in the current directory)
 

5) $ git clean -xf (this is for deleting files that are set to "ignore" in git.)

******Pushing files to github *****

"git pull" and "git push"

note: always to a git pull before a git push

1) git pull = you pull all of the latest code to your local/remote working area repository

2) git push = you push all of your code to the remote repository

3) git clone url (this will clone and download a file from github)( # cloning generally sets up both the names "origin and master" for you automatically )

4) git pull origin master (this is how you pull and updated github repository, but YOU MUST be in the same directory that on your local that your pulling from in github )

(note rememeber anytime you a file change OF ANY KIND... ALWAYS do a " git status ", then if it looks okay do a 'git add' then do a 'git commit -m "your message" )

5) git pull origin master (this will push the commited files to the github repository)
 --->once you hit return github will ask for you user/psw so know it so you can type it.
 --->Once the user/psw has been successful got to the github browser and hit refresh the page and you should see the new push changes.
---> note: if you and someone else from your team does a push on the same file to the repository the first person who pushes wins. So the 2nd persons file will be rejected and will
be forced to do 'pull' request to get the updates changes first. then you must check the file to see any differences so you can 'push' the file back.

always know...
"git pull origin master" means... "origin" is the remote repository and "master" points to the master branch of the remote repository
and...  "git push origin master" means ... "origin" refers to the remote repository and "master" refers to the master branch of your local repository


******************SSH ***********

--> SSH keys are way to identify a trusted computer.

--> generate public/private key pair

--> public keys are meant to share publicly

--> private keys are meant to be kept private to yourself.

to check for ssh on your folders type:  ls -l ~/.ssh

example key file would look like: id_rsa (this would be private key) and id_rsa.pub (this would be public key)

--> you can delete the .ssh keys by typing: rm -rf .ssh (now onc the keys are deleted you can make your own keys)

--> Generate and SSH Keys - RSA

(RSA acronym: Ron Rivest Adi, Shamir, and Leonard Aldeman)
(Cryptosystem: one of the first practical public key cryptosystems)
(RSA Key Length: min length 768 bits; default length: 2048 bits)


to make my own sshe key:
step 1) ssh-keygen -t rsa -b 4096 -C "key pair generation demo"

step 2) you will need to set up password. you can actually just hit return to make it blank for no psw. (once you hit return you will see the SSh finger print key for the SHA256 hash and you will see the public and private key name files made.)

step 3) $ eval "$(ssh-agent -s)"   (this will give you process ID)

step 4) $ ssh-add ~/.ssh/id_rsa.pub

step 5) the password you created will be asked. (one this step is done you have successfully added the key to the ssh agent)

step 6) now add the SSH key to the github account. type: $ clip < ~/.ssh/id_rsa.pub

step 7) go to the github website and click on "setting" and pick "ssh-key" link, then click "new ssh key"
The "title" input box will show and you need to giv it a name. Then in the "key" input box type right click and it paste. next hit the button "Add SSh Key", then hit the "Confirm psw" button. I should see the fingerprint key now added to github.

Note: $ ssh -T -p 443 git@github.com (this to login now form the unix prompt)
 
---------RECAP SSH NOTES---------

Command Summary (GitHub via SSH)
Section 10, Lecture 53

Checking existing SSH Keys

$ ls -al ~/.ssh         # Lists the files in your .ssh directory, if they exist


Generate an SSH Key

# Generates public/private rsa key pair with default values - DON'T RUN THIS ONE
$ ssh-keygen           

 # 't' for type of key, 'b' for length of key, 'C' for comment for maintaining multiple keys                                
$ ssh-keygen -t rsa -b 2048 - C "home machine"

        

Enable SSH Agent & add the SSH Key to the agent

# start the ssh-agent in the background
$ eval "$(ssh-agent -s)"        

# Add your SSH key to the ssh-agent    
$ ssh-add ~/.ssh/id_rsa.pub           


Testing SSH connection

# Verify SSH connection; here 'git" is the user name; note that you cannot use your github user name such as 'william'
$ ssh -T git@github.com                 

# another alternative way to verify if firewall issues are present
$ ssh -T -p 443 git@github.com          


Remote URL switching and SSH push

# List your existing remotes in order to get the name of the remote you want to change
$ git remote -v      

 # set remote URL
$ git git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git       

 # Verify new remote URL  
$ git remote -v                                


Changing passphrase

# for changing password occasionally
$ ssh-keygen -p    



******git diff and git merge ***


1) $ git diff

2) $ git difftool

3) download perforce.com (p4merge tool)

(after you install the p4merge tool from perforce.com you must type these below)

(these steps are for windows)

$ git config --global diff.tool p4merge
$ git config --global difftool.p4merge.path "C:/Program Files/Perforce/p4merge.exe"
$ git config --global difftool.prompt false
$ git config --global merge.tool p4merge
$ git config --global mergetool.p4merge.path "C:/Program Files/Perforce/p4merge.exe"
$ git config --global mergetool.prompt false
$ git config --global  --list


---------merge tools how to read diff -------------

working with difftool on the LEFT side is the staging area RIGHT side is local area

1) $ git diff HEAD (this will hightlight the different line changes)


2) $ git difftool HEAD (this will hightlight the different line changes)

3) $ git diff --staged HEAD OR $ git diff --cached HEAD

4) $ git diff ID HEAD

5) $ git difftool ID HEAD

6) $ git difftool HEAD^ HEAD (yes that is HEAD^ HEAD. i need to remember this line. this will compare the ID you want to the HEAD)

6) $ git difftool HEAD~1 HEAD (yes that is HEAD~1 HEAD. i need to remember this line. this will compare the ID in reverse count from the HEAD. The tilda '~' is like minus sign it subtracts the count from the head, so i can go HEAD~2 from the HEAD)

7) $ git diff ID HEAD (i need to remember this line)

8) $ git difftool ID HEAD (i need to remember this line. this will compare the ID you want to the HEAD^)

9) $ git difftool ID ID (this will compare two ID's instead of comparing against the HEAD)


note: if git stuck in the terminal and i see ":" in the bottom left corner type hit the "space bar" then type the letter "q"


10) $ git diff master localBranchName (this will compare master origin on github to the local origin)


*******Create a NEW branch and to SWITCH BRANCHES*****

1) $ git checkout -b newBranchName (how you create a NEW branch. once you do this it will auto kick you out of the current branch into the create branch)

2) $ git checkout master

3) $ git diff newBranch master (this will run diff between the two branches)

4) $ git difftool newBranch master (this will run diff between the two branches)

------------------------------

******GIT COMMANDS DEEP DIVE


  1.  $ git log --oneline —-decorate —-graph —-all  (this will show information in great details)

  1a.  $ git log -oneline —decorate —graph  (this will show information in great details only show the details for one branch. you will type this ' $ git log -oneline —decorate —graph' after you       switch branches to another by typing this '$ git checkout someBranchName')

  2.  $git log —stat (this will show you files altered and lined deleted. and when you hit space bar you can see files)
  3.  $ git log —stat —oneline -n  2 (limit it two commits)
 * 4.  $ git log -p (this  is to see patches. this is GREAT to see full edit of code for diff.   USE THIS ONE 99% of the time )
  5.  5) $ git log -p —oneline -n 1 (you can limit to just one line of commits or -1)
 * 6.  $ git log  directoryName (this let is GREAT for just looking commit history JUST in a specific directory)
  7.  $ git log —oneline —grep=“football” (how to search for a string in a branch. ‘—grep’ is the key to search lines matching a regular expression) 



****************************



*********** Section 16 video 75 git branching and merging techniques 
***********


note: A git “branch” represents and independent line of development.


We create a NEW BRANCH when we want to develop a new feature or a bug fix no matter if its big or small. Because new code is NEVER committed to the main master branch until its passed in the release QA branch, QA approves its and releases a push to the master branch. A new branch ALWAYS gets town working directory, index or staging area and commit history automatically once you create it.


 1.   $ git branch -a (this means to see ALL the branches you have. it will show all)
 2.   $ git branch a (this will JUST return your local branches)
 3.   $ git branch newBranch name (this is how you make a new branch)
 4.   $ git branch -m currentBranchName NewBranchName (this will change the name of the old current branch to rename it)
 5.   $ git branch -d branchName (this is how you delete a branch)
 6.   $ git branch -D branchName  (this is warning from git that you must type a capital “-D” if you want to delete a sub branch that has NOT been merged. This way git will not allow you to accidentally delete a branch that has changes that you have not merged to the master branch yet just to make sure. So -D will allow you to delete a branch that does not have merged files.) 


note:  you will see all of your branches you will notice that your sub branches are under the master branch. Then you will need to checkout the subbranch you want to work into that branch to create directories and files..



*******DEEPER DIVE INTO BRANCHING


 1.   $ git checkout -b newBranchName master (this is how you make a new branch and copy everything from the master. once you do this 
      do $ git log —online to make sure you have the same commit details. and another way to check is to do a checkout on both branches the new     
  branch and the master to compare history files.)

 note: Understand that when you make a NEW branch it auto inherits the commit history from its parents branch. If you want to control the parent branch make sure you add the name of it
after this command: "$ git checkout -b newBranchName master" and you check this once your new branch is made by " $ git log --oneline " to check the commit history. 

2) $ git checkout -b newBranchName master

**** Fast Foward Merge **********

Before you do a merge ALWAYS do 'git diff' or 'git difftool" on the files first.

 1) $ git git difftool master branchNameFeature
 2) Once you see that the master DOES NOT have your changes then do a merge.
 3) $ git merge nameOfFeatureBranch (also make sure you in the master branch when merging)

	note: warning... YOU CAN NOT DO MERGE UNLESS THE TARGET MERGE IS UP TO DATE!! (so do make sure the files are added and you do a pull request)


************Conflicts *************

 1) $ git mergetool (this gives a 3 way merge look at the conflicts)

  Note: the merge conficted files will show where the conflict starts and stops. When it stops it will show what branch the file is in.

you can make your own ' .ignore" file to stop git from tracking any files you do not want to be kept tracked of.
 
2)  $ git config --global mergetool.keepBackup false (return/enter)

3) $ git config --global --list (return/enter)


**** --amend --no-edit

1) $ git --amend --no-edit (this will allow you commit a file without giving a new message and just keep the message from before without giving git a new snapshot. BUT NEVER use --amend if you have already pushed it to git. only use when add to stage. Because it will look like you erased the entire history of the file.)

*** $ git rebase master ****

 1) $ git rebase master

 2) after check it by typing: "4 git log --online --decorate --graph --all

 3) $ git rebase --abort

 4) $ git rebase --continue (this is run after you fix a merge conflict when rebasing)



***git fetch***


 "orgin/master is the local copy of the remote repo"


1) $ git log --oneline origin/master (this will show me ONLY the local working copies history. you can campare to master if they are     sinked)

--> note: that the "$ git log --oneline origin/master" DOES not allways show everything. So go to github and make sure you have the files.
Not to if see files not in sinc on the github website compared to your local even after you do a "$ git log --oneline origin/master" then
YOU MUST DO A "$ get fetch origin RepoNameBranch"

2) $ git fetch origin master

3) $ git branch -r (shows the invisibale origin/master branches)

4) $ git branch -a ( you can see both local and remote branches)

5) $ git merge origin/master


*********** git pull vs git pull-rebase *****

"git fetch" means brings my local copies up to date with my remote repoitory.

"git pull" = (git fetch) followed by (git merge)...meaining it will bring your local code up to date, THEN merge the code to your repo.

" $ git pull --rebase <remote name> <branch name>  (doing it this way is a clearner build. espcially on smaller files. but for large files
you should do a merge.)


------------------How to create a local master repo and attach it to the git up remote repo -----------

1) Log in to your git hub account. You will need to add the same name as your local in git hub by clicking on "new repository"

2) leave every choice as default and just click "create repository"

3) next you will the instructions for quick setup, create new repository, push repository and import code from another repository.

note: you can always check on the comand line to see if you repo made by typing: $ git remote -v


4) if you get error that say: “fatal: remote origin already exists”  (then do the following)

--> (http://stackoverflow.com/questions/10904339/github-fatal-remote-origin-already-exists)
--> type:  $ git remote add github YOUR-GET-Hub-URL.git (then hit enter)
--> then type $ git remote -v (to check if its there)
-->Remember though, everywhere in the tutorial you see "origin" you should replace it with "github". For example $ git push origin master should now be $ git push github master.

5) usually you would now type: $ git push -u origin  (may not work so type:"$ git push -u github master")
--> however this may not work so replace "origin" with "github" because origin will now be trying to see your local 
so type: $ git push -u github master  (if successfull you will put in user/psw)

(ok)
( i must know this )


***doing a pull request using "--rebase"  and without using --rebase ****

$ git pull --rebase origin master   vs $ git pull origin master



If you do pull request and you dont want to see al of clutter in and you to keep your changes that have been
commited locally BUT NOT pushed so that it stays at the head type. This is best used when pulling in short changes:
$ git pull --rebase origin master

BUT...  if your working on large teams with lots of features then always pull down for updates with :
 $ git pull origin master

now once you have done the pull request ALWAYS check your history: $ git log --oneline —-decorate —-graph —-all


**** $ git show  and $ git reflog   *****

This is GREAT for going back in history by date, time, hour, month. git reflog ONLY shows local history and if you clone a new branch and run a git reflog you will get NO RESULTS because if you have not commit history yet.

NOTE: once you go back into your history in order to restore the file that you want YOU MUST checkou it out into a new brach. a good branch name is: $ checktout -b restoreBranch

Below are commands to know:

1) $ git log -g branchName 

2) $ git show HEAD@{2.months.ago}

3) $ git reset --hard IdNumber

4) git checkout HEAD@{1}



























